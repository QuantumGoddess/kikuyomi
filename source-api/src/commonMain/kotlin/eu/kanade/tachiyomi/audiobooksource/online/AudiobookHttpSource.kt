package eu.kanade.tachiyomi.audiobooksource.online

import eu.kanade.tachiyomi.audiobooksource.AudiobookCatalogueSource
import eu.kanade.tachiyomi.audiobooksource.model.AudiobookFilterList
import eu.kanade.tachiyomi.audiobooksource.model.AudiobooksPage
import eu.kanade.tachiyomi.audiobooksource.model.SAudiobook
import eu.kanade.tachiyomi.audiobooksource.model.SChapter
import eu.kanade.tachiyomi.audiobooksource.model.Audio
import eu.kanade.tachiyomi.network.GET
import eu.kanade.tachiyomi.network.NetworkHelper
import eu.kanade.tachiyomi.network.asObservableSuccess
import eu.kanade.tachiyomi.network.awaitSuccess
import eu.kanade.tachiyomi.network.newCachelessCallWithProgress
import okhttp3.Headers
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.Response
import rx.Observable
import tachiyomi.core.util.lang.awaitSingle
import uy.kohesive.injekt.injectLazy
import java.net.URI
import java.net.URISyntaxException
import java.security.MessageDigest

/**
 * A simple implementation for sources from a website.
 */
@Suppress("unused")
abstract class AudiobookHttpSource : AudiobookCatalogueSource {

    /**
     * Network service.
     */
    protected val network: NetworkHelper by injectLazy()

    /**
     * Base url of the website without the trailing slash, like: http://mysite.com
     */
    abstract val baseUrl: String

    /**
     * Version id used to generate the source id. If the site completely changes and urls are
     * incompatible, you may increase this value and it'll be considered as a new source.
     */
    open val versionId = 1

    /**
     * ID of the source. By default it uses a generated id using the first 16 characters (64 bits)
     * of the MD5 of the string `"${name.lowercase()}/$lang/$versionId"`.
     *
     * The ID is generated by the [generateId] function, which can be reused if needed
     * to generate outdated IDs for cases where the source name or language needs to
     * be changed but migrations can be avoided.
     *
     * Note: the generated ID sets the sign bit to `0`.
     */
    override val id by lazy { generateId(name, lang, versionId) }

    /**
     * Headers used for requests.
     */
    val headers: Headers by lazy { headersBuilder().build() }

    /**
     * Default network client for doing requests.
     */
    open val client: OkHttpClient
        get() = network.client

    /**
     * Generates a unique ID for the source based on the provided [name], [lang] and
     * [versionId]. It will use the first 16 characters (64 bits) of the MD5 of the string
     * `"${name.lowercase()}/$lang/$versionId"`.
     *
     * Note: the generated ID sets the sign bit to `0`.
     *
     * Can be used to generate outdated IDs, such as when the source name or language
     * needs to be changed but migrations can be avoided.
     *
     * @since extensions-lib 1.5
     * @param name [String] the name of the source
     * @param lang [String] the language of the source
     * @param versionId [Int] the version ID of the source
     * @return a unique ID for the source
     */
    @Suppress("MemberVisibilityCanBePrivate")
    protected fun generateId(name: String, lang: String, versionId: Int): Long {
        val key = "${name.lowercase()}/$lang/$versionId"
        val bytes = MessageDigest.getInstance("MD5").digest(key.toByteArray())
        return (0..7).map { bytes[it].toLong() and 0xff shl 8 * (7 - it) }.reduce(Long::or) and Long.MAX_VALUE
    }

    /**
     * Headers builder for requests. Implementations can override this method for custom headers.
     */
    protected open fun headersBuilder() = Headers.Builder().apply {
        add("User-Agent", network.defaultUserAgentProvider())
    }

    /**
     * Visible name of the source.
     */
    override fun toString() = "$name (${lang.uppercase()})"

    /**
     * Returns an observable containing a page with a list of audiobook. Normally it's not needed to
     * override this method.
     *
     * @param page the page number to retrieve.
     */
    @Deprecated(
        "Use the non-RxJava API instead",
        ReplaceWith("getPopularAudiobook"),
    )
    override fun fetchPopularAudiobook(page: Int): Observable<AudiobooksPage> {
        return client.newCall(popularAudiobookRequest(page))
            .asObservableSuccess()
            .map { response ->
                popularAudiobookParse(response)
            }
    }

    /**
     * Returns the request for the popular audiobook given the page.
     *
     * @param page the page number to retrieve.
     */
    protected abstract fun popularAudiobookRequest(page: Int): Request

    /**
     * Parses the response from the site and returns a [AudiobooksPage] object.
     *
     * @param response the response from the site.
     */
    protected abstract fun popularAudiobookParse(response: Response): AudiobooksPage

    /**
     * Returns an observable containing a page with a list of audiobook. Normally it's not needed to
     * override this method.
     *
     * @param page the page number to retrieve.
     * @param query the search query.
     * @param filters the list of filters to apply.
     */
    @Deprecated(
        "Use the non-RxJava API instead",
        ReplaceWith("getSearchAudiobook"),
    )
    override fun fetchSearchAudiobook(page: Int, query: String, filters: AudiobookFilterList): Observable<AudiobooksPage> {
        return Observable.defer {
            try {
                client.newCall(searchAudiobookRequest(page, query, filters)).asObservableSuccess()
            } catch (e: NoClassDefFoundError) {
                // RxJava doesn't handle Errors, which tends to happen during global searches
                // if an old extension using non-existent classes is still around
                throw RuntimeException(e)
            }
        }
            .map { response ->
                searchAudiobookParse(response)
            }
    }

    /**
     * Returns the request for the search audiobook given the page.
     *
     * @param page the page number to retrieve.
     * @param query the search query.
     * @param filters the list of filters to apply.
     */
    protected abstract fun searchAudiobookRequest(page: Int, query: String, filters: AudiobookFilterList): Request

    /**
     * Parses the response from the site and returns a [AudiobooksPage] object.
     *
     * @param response the response from the site.
     */
    protected abstract fun searchAudiobookParse(response: Response): AudiobooksPage

    /**
     * Returns an observable containing a page with a list of latest audiobook updates.
     *
     * @param page the page number to retrieve.
     */
    @Deprecated(
        "Use the non-RxJava API instead",
        ReplaceWith("getLatestUpdates"),
    )
    override fun fetchLatestUpdates(page: Int): Observable<AudiobooksPage> {
        return client.newCall(latestUpdatesRequest(page))
            .asObservableSuccess()
            .map { response ->
                latestUpdatesParse(response)
            }
    }

    /**
     * Returns the request for latest audiobook given the page.
     *
     * @param page the page number to retrieve.
     */
    protected abstract fun latestUpdatesRequest(page: Int): Request

    /**
     * Parses the response from the site and returns a [AudiobooksPage] object.
     *
     * @param response the response from the site.
     */
    protected abstract fun latestUpdatesParse(response: Response): AudiobooksPage

    /**
     * Get the updated details for a audiobook.
     * Normally it's not needed to override this method.
     *
     * @param audiobook the audiobook to be updated.
     * @return the updated audiobook.
     */
    @Suppress("DEPRECATION")
    override suspend fun getAudiobookDetails(audiobook: SAudiobook): SAudiobook {
        return fetchAudiobookDetails(audiobook).awaitSingle()
    }

    @Deprecated("Use the non-RxJava API instead", replaceWith = ReplaceWith("getAudiobookDetails"))
    override fun fetchAudiobookDetails(audiobook: SAudiobook): Observable<SAudiobook> {
        return client.newCall(audiobookDetailsRequest(audiobook))
            .asObservableSuccess()
            .map { response ->
                audiobookDetailsParse(response).apply { initialized = true }
            }
    }

    /**
     * Returns the request for the details of an audiobook. Override only if it's needed to change the
     * url, send different headers or request method like POST.
     *
     * @param audiobook the audiobook to be updated.
     */
    open fun audiobookDetailsRequest(audiobook: SAudiobook): Request {
        return GET(baseUrl + audiobook.url, headers)
    }

    /**
     * Parses the response from the site and returns the details of an audiobook.
     *
     * @param response the response from the site.
     */
    protected abstract fun audiobookDetailsParse(response: Response): SAudiobook

    /**
     * Get all the available chapters for an audiobook.
     * Normally it's not needed to override this method.
     *
     * @param audiobook the audiobook to update.
     * @return the chapters for the manga.
     * @throws LicensedEntryItemsException if a audiobook is licensed and therefore no chapters are available.
     */
    @Suppress("DEPRECATION")
    override suspend fun getChapterList(audiobook: SAudiobook): List<SChapter> {
        if (audiobook.status == SAudiobook.LICENSED) {
            throw LicensedEntryItemsException()
        }

        return fetchChapterList(audiobook).awaitSingle()
    }

    @Deprecated("Use the non-RxJava API instead", replaceWith = ReplaceWith("getChapterList"))
    override fun fetchChapterList(audiobook: SAudiobook): Observable<List<SChapter>> {
        return if (audiobook.status != SAudiobook.LICENSED) {
            client.newCall(chapterListRequest(audiobook))
                .asObservableSuccess()
                .map { response ->
                    chapterListParse(response)
                }
        } else {
            Observable.error(LicensedEntryItemsException())
        }
    }

    /**
     * Returns the request for updating the chapter list. Override only if it's needed to override
     * the url, send different headers or request method like POST.
     *
     * @param audiobook the audiobook to look for chapters.
     */
    protected open fun chapterListRequest(audiobook: SAudiobook): Request {
        return GET(baseUrl + audiobook.url, headers)
    }

    /**
     * Parses the response from the site and returns a list of chapters.
     *
     * @param response the response from the site.
     */
    protected abstract fun chapterListParse(response: Response): List<SChapter>

    /**
     * Parses the response from the site and returns a SChapter Object.
     *
     * @param response the response from the site.
     */
    protected abstract fun chapterAudioParse(response: Response): SChapter

    /**
     * Get the list of audios a chapter has. Audios should be returned
     * in the expected order; the index is ignored.
     *
     * @param chapter the chapter.
     * @return the audios for the chapter.
     */
    @Suppress("DEPRECATION")
    override suspend fun getAudioList(chapter: SChapter): List<Audio> {
        return fetchAudioList(chapter).awaitSingle()
    }

    @Deprecated("Use the non-RxJava API instead", replaceWith = ReplaceWith("getAudioList"))
    override fun fetchAudioList(chapter: SChapter): Observable<List<Audio>> {
        return client.newCall(audioListRequest(chapter))
            .asObservableSuccess()
            .map { response ->
                audioListParse(response).sort()
            }
    }

    /**
     * Returns the request for getting the chapter link. Override only if it's needed to override
     * the url, send different headers or request method like POST.
     *
     * @param chapter the chapter to look for links.
     */
    protected open fun audioListRequest(chapter: SChapter): Request {
        return GET(baseUrl + chapter.url, headers)
    }

    /**
     * Parses the response from the site and returns a list of pages.
     *
     * @param response the response from the site.
     */
    protected abstract fun audioListParse(response: Response): List<Audio>

    /**
     * Sorts the audio list. Override this according to the user's preference.
     */
    protected open fun List<Audio>.sort(): List<Audio> {
        return this
    }

    /**
     * Returns an observable with the page containing the source url of the image. If there's any
     * error, it will return null instead of throwing an exception.
     *
     * @since extensions-lib 1.5
     * @param audio the audio whose source image has to be fetched.
     */
    @Suppress("DEPRECATION")
    open suspend fun getAudioUrl(audio: Audio): String {
        return fetchAudioUrl(audio).awaitSingle()
    }

    @Deprecated("Use the non-RxJava API instead", replaceWith = ReplaceWith("getAudioUrl"))
    open fun fetchAudioUrl(audio: Audio): Observable<String> {
        return client.newCall(audioUrlRequest(audio))
            .asObservableSuccess()
            .map { audioUrlParse(it) }
    }

    /**
     * Returns the request for getting the url to the source image. Override only if it's needed to
     * override the url, send different headers or request method like POST.
     *
     * @param audio the chapter whose page list has to be fetched
     */
    protected open fun audioUrlRequest(audio: Audio): Request {
        return GET(audio.url, headers)
    }

    /**
     * Parses the response from the site and returns the absolute url to the source image.
     *
     * @param response the response from the site.
     */
    protected abstract fun audioUrlParse(response: Response): String

    /**
     * Returns the response of the source audio.
     * Typically does not need to be overridden.
     *
     * @since extensions-lib 1.5
     * @param audio the audio whose source audio has to be downloaded.
     */
    open suspend fun getAudio(audio: Audio): Response {
        return client.newCachelessCallWithProgress(audioRequest(audio), audio)
            .awaitSuccess()
    }

    /**
     * Returns the request for getting the source image. Override only if it's needed to override
     * the url, send different headers or request method like POST.
     *
     * @param audio the audio whose link has to be fetched
     */
    protected open fun audioRequest(audio: Audio, bytes: Long = 0L): Request {
        val headers = audio.headers ?: headers
        val newHeaders = if (bytes > 0L) {
            Headers.Builder().addAll(headers).add("Range", "bytes=$bytes-").build()
        } else {
            null
        }
        return GET(audio.audioUrl!!, newHeaders ?: headers)
    }

    /**
     * Assigns the url of the chapter without the scheme and domain. It saves some redundancy from
     * database and the urls could still work after a domain change.
     *
     * @param url the full url to the chapter.
     */
    fun SChapter.setUrlWithoutDomain(url: String) {
        this.url = getUrlWithoutDomain(url)
    }

    /**
     * Assigns the url of the audiobook without the scheme and domain. It saves some redundancy from
     * database and the urls could still work after a domain change.
     *
     * @param url the full url to the audiobook.
     */
    fun SAudiobook.setUrlWithoutDomain(url: String) {
        this.url = getUrlWithoutDomain(url)
    }

    /**
     * Returns the url of the given string without the scheme and domain.
     *
     * @param orig the full url.
     */
    private fun getUrlWithoutDomain(orig: String): String {
        return try {
            val uri = URI(orig)
            var out = uri.path
            if (uri.query != null) {
                out += "?" + uri.query
            }
            if (uri.fragment != null) {
                out += "#" + uri.fragment
            }
            out
        } catch (e: URISyntaxException) {
            orig
        }
    }

    /**
     * Returns the url of the provided audiobook
     *
     * @since extensions-lib 14
     * @param audiobook the audiobook
     * @return url of the audiobook
     */
    open fun getAudiobookUrl(audiobook: SAudiobook): String {
        return audiobookDetailsRequest(audiobook).url.toString()
    }

    /**
     * Returns the url of the provided chapter
     *
     * @since extensions-lib 14
     * @param chapter the chapter
     * @return url of the chapter
     */
    open fun getChapterUrl(chapter: SChapter): String {
        return chapter.url.toString()
    }

    /**
     * Called before inserting a new chapter into database. Use it if you need to override chapter
     * fields, like the title or the chapter number. Do not change anything to [audiobook].
     *
     * @param chapter the chapter to be added.
     * @param audiobook the audiobook of the chapter.
     */
    open fun prepareNewChapter(chapter: SChapter, audiobook: SAudiobook) {}

    /**
     * Returns the list of filters for the source.
     */
    override fun getFilterList() = AudiobookFilterList()
}

class LicensedEntryItemsException : Exception("Licensed - No items to show")
